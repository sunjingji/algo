#pragma once

// ------------------------------------------------------------------------------
// 程序设计思想
// ❑ 等价性原理
//    对问题进行抽象，转换成等价的已知问题，达到一通百通的效果。
//    在考虑问题时，可以尝试不同尺度的视角，比如在用A*算法解决游戏中人物的寻路问题，规划北京某地到上海某地的导航问题，都需要把视角拉远了，忽略掉细节，先解决大视角的问题。
// ❑ 分治思想
//    分而治之，古老的智慧。
// ❑ 递归思想
//    基于确定性的步骤，逐步缩小问题的规模，解决最小不可分割的问题之后，再回头来解决大规模的问题(回溯)，这是计算机思维的基础思想。
// ❑ 并行算法
//   并行计算是一个工程上的实现思路，尽管跟算法关系不大，但是，在实际的软件开发中，它确实可以非常巧妙地提高程序的运行效率，是一种非常好用的性能优化手段。
//   特别是，当要处理的数据规模达到一定程度之后，我们无法通过继续优化算法，来提高执行效率 的时候，我们就需要在实现的思路上做文章，利用更多的硬件资源，来加快执行的效率。
//   所以，在很多超大规模数据处理中，并行处理的思想，应用非常广泛，比如 MapReduce 实际上就是一种并行计算框架。
// ❑ 复用，少做事情，动态规划思想
//    要高效就要少做事情。对问题的分析要透彻，在计算过程中要运用动态规划思想，尽可能的复用子问题的解。
// ❑ 分析问题的特殊性，设计专用数据结构和算法
//    例如，计数排序是对桶排序的极端版本。当要排序的n个数据，所处的范围并不大的时候，比如最大值是k，我们就可以把数据划分成k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。
// ❑ 形象化思考
//    以手绘图形的方式，使用栈、树、图等基础数据结构，把抽象问题形象化。
// ❑ 三思而后行
//   考虑清楚完整逻辑再动手写程序，不要急于动手。
//
// ------------------------------------------------------------------------------
// 复杂度分析
// ❑ 大O记法
// ❑ 最好、最坏、平均复杂度
// ❑ 摊还分析，均摊时间复杂度就是一种特殊的平均时间复杂度。
//    对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系。
//    这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。
// ❑ 数据分析
//    分析排序算法的时间复杂度时，基于逆序度 = 满有序度 - 有序度，来分析需要执行的交换操作次数。
// ❑ 递归代码分析：递推公式分析，递归树分析法。

// 递归
// 写递归代码的关键就是找到如何将大问题分解为小问题的规律，写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。
// 编写递归代码要警惕：堆栈溢出，和重复计算。

// 贪心算法
// 每一步都选择最优解，最终得到全局最优解。
// 不适用贪心算法的例子，图的最短路径问题。前面的选择，会影响后面的选择。所以，即便我们第一步选择最优的走法(边最短)，但有可能因为这一步选择，导致后面每一步的选择都很糟糕，最终也就无缘全局最优解了。

// 分治算法
// 分治算法的核心思想其实就是四个字，分而治之，也就是将原问题划分成n个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。
// 分治算法能解决的问题，一般需要满足下面这几个条件：
//   ❑ 原问题与分解成的小问题具有相同的模式；
//   ❑ 原问题分解成的子问题可以独立求解，“子问题之间没有相关性”，这一点是分治算法跟动态规划的明显区别；
//   ❑ 具有分解终止条件，也就是说，当问题足够小时，可以直接求解；
//   ❑ 可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。
// 分治算法的递归实现中，每一层递归都会涉及这样三个操作：
//   ❑ 分解：将原问题分解成一系列子问题；
//   ❑ 解决：递归地求解各个子问题，若子问题足够小，则直接求解；
//   ❑ 合并：将子问题的结果合并成原问题。

// 回溯算法
// 回溯算法的思想非常简单，大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。
// 通常问题的的解是一个向量(a1,a2...an)，每一步决定解的一个片段，如果把解空间看成一个树，求解过程就是一个先序遍历过程。
// 回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。

// 动态规划
// 动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。
// 问题特征：
//   ❑ 最优子结构
//     可以通过子问题的解，推导出问题的最优解。
//   ❑ 无后效性
//     在推导后面阶段的状态的时候，我们只关心前面的状态值，不关心这个状态是怎么一步一步推导出来的。
//     某阶段状态一旦确定，就不受之后阶段的决策影响。
//   ❑ 重复子问题
// 算法特征：
//   ❑ 复用子问题的解；
//   ❑ 算法复杂度 O(N*M)；
//   ❑ 双重循环(决策步骤递增，在每个决策步骤解决每个子问题)；
// 算法设计：
//   ❑ 使用状态转移表，分析问题；
//   ❑ 使用最优子结构，写出状态转移方程；
//   ❑ 先写出最朴素的回溯代码，再转换成状态转移表或状态转移方程；
// 小贴士：
//   ❑ 每种动态规划解决方案都涉及网格。
//   ❑ 单元格中的值通常就是你要优化的值。
//   ❑ 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴。
// 常见问题：
//   ❑ 背包问题
//   ❑ 最长公共字串
//   ❑ 最长公共子序列
//   ❑ 最长递增序列
//   ❑ 编辑距离（判断相似度）
//
// ------------------------------------------------------------------------------