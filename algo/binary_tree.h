#pragma once

/*
 * 二叉查找树
 * 左子节点 < 父节点 < 右子节点
 *
 *
 * 平衡二叉树
 * 二叉树中任意一个节点的左右子树的高度相差不能大于1；
 * 其实就是让整颗树左右看起来比较“对称”，比较“平衡”，不要出现左子树很高，右子树很矮的情况；
 * 这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些；
 * 
 *
 * AVL树
 *   最先被发明出来的平衡二叉树，它严格符合平衡二叉查找树的定义。
 *
 *
 * 红黑树
 * 规则：
 *   root节点为黑色(从规则1和规则2推导)；
 *   每个叶子节点都是黑色的空节点(NIL)，也就是说，叶子节点不存储数据；
 *   红色节点不能相邻(父子关系)，必须被黑色节点隔开；
 *   每个节点到所有后代叶子节点的路径上，都包含梳理相同的黑色节点；
 *   插入节点为红色节点；
 * 理解红黑树实现的要点：
 *   1)推导Case
 *     根据红黑树定义，推导可能的子树结构(3层就可以)，剪掉不需要调整的子树结构，确定所有需要调整的Case；
 *   2)递归调整
 *     先在子树内调整到位，然后把子树当做一个节点，看是否需要继续调整上级子树(也就是关注点切换)；
 *   3)分步调整
 *     对于不好一步到位的调整, 分步实施(例如, 先保证子树满足规则4, 再满足规则3)；
 * 适用场合：
 *   红黑树只是做到了近似平衡，并不是严格的平衡，在维护成本上，比AVL树要低；
 *   树的高度比较稳定地趋近logN，但凡用到动态插入、删除、查找数据的场景，都可以用红黑树；
 *   但红黑树实现比较复杂，如果需要手写代码，通常可以用跳表替代；
 */